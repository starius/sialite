package transaction

/*
* This file is machine generated by fs2-generic. You can obtain
* fs2-generic from github.com/timtadh/fs2/fs2-generic . To install
*
*   $ go get github.com/timtadh/fs2
*   $ go install github.com/timtadh/fs2/fs2-generic
*
* The command used to generate the file was
*
*   $ fs2-generic \
*     --output=transaction/wrapper.go \
*     --package-name=transaction \
*     bptree \
*     --key-type=github.com/NebulousLabs/Sia/crypto/Hash \
*     --key-size=32 \
*     --key-serializer=github.com/starius/sialite/fs2wrapper/hash/Serialize \
*     --key-deserializer=github.com/starius/sialite/fs2wrapper/hash/Deserialize \
*     --key-empty=crypto.Hash{} \
*     --value-type=Location \
*     --value-serializer=Serialize \
*     --value-deserializer=Deserialize \
*     --value-empty=Location{}
*
* By including this code (and linking to github.com/timtadh/fs2) you
* accept the terms of the GPL version 3 unless another license has been
* obtained in writing from the author(s) of the package. The list of
* authors and full licensing information is located at
* https://github.com/timtadh/fs2/LICENSE
*
* This library is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 3 of the License, or (at
* your option) any later version.
*
* This library is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this library; if not, write to the Free Software
* Foundation, Inc.,
*   51 Franklin Street, Fifth Floor,
*   Boston, MA  02110-1301
*   USA
 */

import (
	"sync"
)

import (
	"github.com/timtadh/fs2"
	"github.com/timtadh/fs2/bptree"
	"github.com/timtadh/fs2/fmap"
)

import (
	"github.com/NebulousLabs/Sia/crypto"
	"github.com/starius/sialite/fs2wrapper/hash"
)

type MultiMap interface {
	Keys() (KeyIterator, error)
	Values() (ValueIterator, error)
	Iterate() (Iterator, error)
	Backward() (Iterator, error)
	Find(key crypto.Hash) (Iterator, error)
	DoFind(key crypto.Hash, do func(crypto.Hash, Location) error) error
	Range(from, to crypto.Hash) (Iterator, error)
	DoRange(from, to crypto.Hash, do func(crypto.Hash, Location) error) error
	Has(key crypto.Hash) (bool, error)
	Count(key crypto.Hash) (int, error)
	Add(key crypto.Hash, value Location) error
	Remove(key crypto.Hash, where func(Location) bool) error
	Size() int
	Close() error
	Delete() error
}

type Iterator func() (crypto.Hash, Location, error, Iterator)
type KeyIterator func() (crypto.Hash, error, KeyIterator)
type ValueIterator func() (Location, error, ValueIterator)

func Do(run func() (Iterator, error), do func(key crypto.Hash, value Location) error) error {
	kvi, err := run()
	if err != nil {
		return err
	}
	var key crypto.Hash
	var value Location
	for key, value, err, kvi = kvi(); kvi != nil; key, value, err, kvi = kvi() {
		e := do(key, value)
		if e != nil {
			return e
		}
	}
	return err
}

func DoKey(run func() (KeyIterator, error), do func(crypto.Hash) error) error {
	it, err := run()
	if err != nil {
		return err
	}
	var item crypto.Hash
	for item, err, it = it(); it != nil; item, err, it = it() {
		e := do(item)
		if e != nil {
			return e
		}
	}
	return err
}

func DoValue(run func() (ValueIterator, error), do func(Location) error) error {
	it, err := run()
	if err != nil {
		return err
	}
	var item Location
	for item, err, it = it(); it != nil; item, err, it = it() {
		e := do(item)
		if e != nil {
			return e
		}
	}
	return err
}

type BpTree struct {
	bf    *fmap.BlockFile
	bpt   *bptree.BpTree
	mutex sync.Mutex
}

func AnonBpTree() (*BpTree, error) {
	bf, err := fmap.Anonymous(fmap.BLOCKSIZE)
	if err != nil {
		return nil, err
	}
	return newBpTree(bf)
}

func NewBpTree(path string) (*BpTree, error) {
	bf, err := fmap.CreateBlockFile(path)
	if err != nil {
		return nil, err
	}
	return newBpTree(bf)
}

func OpenBpTree(path string) (*BpTree, error) {
	bf, err := fmap.OpenBlockFile(path)
	if err != nil {
		return nil, err
	}
	bpt, err := bptree.Open(bf)
	if err != nil {
		return nil, err
	}
	b := &BpTree{
		bf:  bf,
		bpt: bpt,
	}
	return b, nil
}

func newBpTree(bf *fmap.BlockFile) (*BpTree, error) {
	bpt, err := bptree.New(bf, 32, -1)
	if err != nil {
		return nil, err
	}
	b := &BpTree{
		bf:  bf,
		bpt: bpt,
	}
	return b, nil
}

func (b *BpTree) Close() error {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bf.Close()
}

func (b *BpTree) Delete() error {
	err := b.Close()
	if err != nil {
		return err
	}
	if b.bf.Path() != "" {
		return b.bf.Remove()
	}
	return nil
}

func (b *BpTree) Size() int {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Size()
}

func (b *BpTree) Add(key crypto.Hash, val Location) error {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Add(hash.Serialize(key), Serialize(val))
}

func (b *BpTree) Count(key crypto.Hash) (int, error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Count(hash.Serialize(key))
}

func (b *BpTree) Has(key crypto.Hash) (bool, error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Has(hash.Serialize(key))
}

func (b *BpTree) kvIter(kvi fs2.Iterator) (it Iterator) {
	it = func() (key crypto.Hash, value Location, err error, _ Iterator) {
		b.mutex.Lock()
		defer b.mutex.Unlock()
		var k, v []byte
		k, v, err, kvi = kvi()
		if err != nil {
			return crypto.Hash{}, Location{}, err, nil
		}
		if kvi == nil {
			return crypto.Hash{}, Location{}, nil, nil
		}
		key = hash.Deserialize(k)
		value = Deserialize(v)
		return key, value, nil, it
	}
	return it
}

func (b *BpTree) keyIter(raw fs2.ItemIterator) (it KeyIterator) {
	it = func() (key crypto.Hash, err error, _ KeyIterator) {
		b.mutex.Lock()
		defer b.mutex.Unlock()
		var i []byte
		i, err, raw = raw()
		if err != nil {
			return crypto.Hash{}, err, nil
		}
		if raw == nil {
			return crypto.Hash{}, nil, nil
		}
		key = hash.Deserialize(i)
		return key, nil, it
	}
	return it
}

func (b *BpTree) valueIter(raw fs2.ItemIterator) (it ValueIterator) {
	it = func() (value Location, err error, _ ValueIterator) {
		b.mutex.Lock()
		defer b.mutex.Unlock()
		var i []byte
		i, err, raw = raw()
		if err != nil {
			return Location{}, err, nil
		}
		if raw == nil {
			return Location{}, nil, nil
		}
		value = Deserialize(i)
		return value, nil, it
	}
	return it
}

func (b *BpTree) Keys() (it KeyIterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Keys()
	if err != nil {
		return nil, err
	}
	return b.keyIter(raw), nil
}

func (b *BpTree) Values() (it ValueIterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Values()
	if err != nil {
		return nil, err
	}
	return b.valueIter(raw), nil
}

func (b *BpTree) Find(key crypto.Hash) (it Iterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Find(hash.Serialize(key))
	if err != nil {
		return nil, err
	}
	return b.kvIter(raw), nil
}

func (b *BpTree) DoFind(key crypto.Hash, do func(crypto.Hash, Location) error) error {
	return Do(func() (Iterator, error) { return b.Find(key) }, do)
}

func (b *BpTree) Iterate() (it Iterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Iterate()
	if err != nil {
		return nil, err
	}
	return b.kvIter(raw), nil
}

func (b *BpTree) Range(from, to crypto.Hash) (it Iterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Range(hash.Serialize(from), hash.Serialize(to))
	if err != nil {
		return nil, err
	}
	return b.kvIter(raw), nil
}

func (b *BpTree) DoRange(from, to crypto.Hash, do func(crypto.Hash, Location) error) error {
	return Do(func() (Iterator, error) { return b.Range(from, to) }, do)
}

func (b *BpTree) Backward() (it Iterator, err error) {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	raw, err := b.bpt.Backward()
	if err != nil {
		return nil, err
	}
	return b.kvIter(raw), nil
}

func (b *BpTree) Remove(key crypto.Hash, where func(Location) bool) error {
	b.mutex.Lock()
	defer b.mutex.Unlock()
	return b.bpt.Remove(hash.Serialize(key), func(bytes []byte) bool {
		return where(Deserialize(bytes))
	})
}
